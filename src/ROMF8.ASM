	TTL	ROMF8 - CONTROL AT FXXX - 12/22/80
	SETDP	$A0
*
* SYSTEM EQUATES
* 
DIAORG	EQU	$C000
DIABLK	EQU	3	DIAGNOSTIC BLOCK
CMOS	EQU	$C400
CMOS$	EQU	$C480	WRITE PROTECTED
MAPC	EQU	$D000	FLOPPING ADDRESS
MAPCR	EQU	$A036
CREDIT	EQU	$A037
CUNITS	EQU	$A038
BUNITS	EQU	$A039
*
* CMOS RAM ALLOCATION
*
	ORG	CMOS
DIPFLG	RMB	1	DIP SWITCH SET FLAG
SLOT1	RMB	4	LEFT COIN TOTAL
SLOT2	RMB	4	CENTER COIN TOTAL
SLOT3	RMB	4	RIGHT COIN TOTAL
TOTPDC	RMB	4	TOTAL PAID CREDITS
TOTRPL	RMB	4	TOTAL REPLAYS
BLLTIM	RMB	4	BALL TIME IN MINS
BLLCNT	RMB	4	TOTAL "BALLS" PLAYED
CMSDEF	EQU	*
CRHSTD	RMB	12	FOR ALL TIME HSTD
CRHST1	RMB	12	ALL TIME #2
CRHST2	RMB	12
CRHST3	RMB	12
CRHST4	RMB	12
CRHST5	RMB	12
CRHST6	RMB	12
CRHST7	RMB	12
CREDST	EQU	*	CREDITS BACKUP
DIPSW	RMB	2	FOR DIPSW FUNCTIONS
	ORG	CMOS$-1	PUT IT ACCROSS BOUNDARY
CMOSCK	RMB	2	FOR BOUNDARY BYTE
REPLAY	RMB	4	REPLAY LEVEL
NSHIP	RMB	2	NUMBER OF SHIPS/GAME
COINSL	RMB	2	FOR COINAGE SELECT MODE
SLOT1M	RMB	2	LEFT COIN MULT
SLOT2M	RMB	2	CENTER COIN MULT
SLOT3M	RMB	2	RIGHT COIN MULT
CUNITC	RMB	2	COIN UNITS PER CREDIT
CUNITB	RMB	2	COIN UNITS FOR BONUS
MINUNT	RMB	2	MINIMUM REQD
FREEPL	RMB	2	FREE PLAY MODE
GA1	RMB	2	GAME ADJUSTS - 1
GA2	RMB	2
GA3	RMB	2
GA4	RMB	2
GA5	RMB	2
GA6	RMB	2
GA7	RMB	2
GA8	RMB	2
GA9	RMB	2
GA10	RMB	2
*
* RESET PROCESSING
*
	ORG	$FB00	TEMPORARY!!!!!!
RESET	CLR	MAPC	SETUP PIAS
	LDX	#$CC00
	CLR	1,X
	CLR	3,X
	CLR	5,X
	CLR	7,X
	LDA	#$C0
	STA	,X
	LDA	#$FF
	STA	2,X
	CLR	4,X	
	CLR	6,X
	LDA	#4
	STA	3,X
	STA	5,X
	STA	7,X
	ORA	#$10	SET FOR SLAM SW ON ^TRANS
	STA	1,X	AND PROGRAM
	LDX	#$C000	SET INTERESTING SCREEN COLORS
	LDA	#$C0
RESET1	STA	,X+
	LDB	#$B5
	MUL
	CMPX	#$C010
	BNE	RESET1
	ORCC	#$80	SET AUTO CYCLE NOT FLAG <=================TEMPORARY
	ANDCC	#$EF	CLEAR COMPREHENSIVE/INITIAL FLAG(I BIT)
*
* POWER UP RAM TEST
*
	LDY	#7	SET TEST COUNTER
	CLRA
	TFR	A,DP	CLEAR BAD RAM MAP(BIT 0-BLOCK 1, B1-BL2 , B2-BL3)
	ANDCC	#$BF	INITIALIZE BAD RAM IN PAGE FLAG(F BIT)
	CLRB
RAM2	TFR	D,U	SAVE SEED
	LDX	#0	GET STARTING ADDRESS INTO POINTER
RAM3	COMB		RANDOM NUMBER ROUTINE
	BITB	#9
	BNE	RAM4
	COMB
	RORA
	RORB
	BRA	RAM6
RAM4	COMB
	BITB	#9
	BNE	RAM5
	RORA
	RORB
	BRA	RAM6
RAM5	LSRA
	RORB
RAM6	STD	,X++	LOAD INTO ADDRESS AND ADVANCE
	EXG	X,D	WATCHDOG TEST
	TSTB
	BNE	RAM6B
	LDB	#$38	RESET WATCHDOG
	STB	$C3FC
	TFR	CC,B	CHECK COMPREHENSIVE/INITIAL FLAG
	BITB	#$10
	BEQ	RAM6A	SKIP IF INITIAL
	CLR	MAPC	SELECT PIA BLOCK
	LDB	$CC00	CHECK IF ADVANCE PRESSED AND AUTO UP
	COMB
	BITB	#3
	BEQ	RAM11A	TEST ABORTED, RETURN TO COMPREHENSIVE
RAM6A	CLRB
RAM6B	EXG	X,D
	CMPX	#$C000	ADDRESS POINTER  DONE?
	BNE	RAM3	NO, LOOP
	TFR	U,D	GET SEED
	LDX	#0	GET STARTING ADDRESS INTO POINTER
RAM7	COMB		RANDOM NUMBER ROUTINE
	BITB	#9
	BNE	RAM8
	COMB
	RORA
	RORB
	BRA	RAM10
RAM8	COMB
	BITB	#9
	BNE	RAM9
	RORA
	RORB
	BRA	RAM10
RAM9	LSRA
	RORB
RAM10	CMPD	,X++	CHECK FOR MATCH
	BEQ	RAM11	NO, ERROR
	EXG	D,Y	SAVE ERROR
	TFR	CC,A	CHECK COMPREHENSIVE/INITIAL FLAG
	BITA	#$10
	BEQ	RAM10A	SKIP IF INITIAL
	LDA	#DIABLK	ERROR, RETURN TO COMPREHENSIVE
	STA	MAPCR
	STA	MAPC	AND IN HARDWARE
	JMP	VRAM10
RAM10A	CLRA
	EXG	Y,D	RECOVER COUNTER
	ORCC	#$40	SET BAD RAM IN PAGE FLAG
RAM11	EXG	X,D	END OF PAGE TEST
	TSTB
	BNE	RAM17	PAGE NOT DONE
	TFR	CC,B	CHECK COMPREHENSIVE/INITIAL FLAG
	BITB	#$10
	BEQ	RAM11B	SKIP IF INITIAL
	LDB	$CC00	CHECK IF ADVANCE PRESSED AND AUTO UP
	COMB
	BITB	#3
	BNE	RAM16	NOT YET, SKIP ERROR PROCESSING SAVE DP
RAM11A	LDA	#DIABLK	TEST ABORTED, RETURN TO COMPREHENSIVE
	STA	MAPCR	IN FLAG
	STA	MAPC
	JMP	VRAM20
RAM11B	TFR	CC,B	GET CONDITION CODES
	BITB	#$40	CHECK BAD RAM IN PAGE FLAG
	BEQ	RAM16	RAM PAGE OK-SKIP ERROR PROCESSING
* ERROR PROCESSING
	ANDCC	#$BF	CLEAR BAD RAM IN PAGE FLAG
	TFR	DP,B	GET BAD RAM MAP
	TFR	A,DP	SAVE ADDRESS
RAM12	SUBA	#3	FIND BLOCK NUMBER
	BCC	RAM12
	INCA
	BNE	RAM13
	ORB	#2	BLOCK 2
	BRA	RAM15
RAM13	INCA
	BNE	RAM14
	ORB	#1	BLOCK 1
	BRA	RAM15
RAM14	ORB	#4	BLOCK 3
RAM15	TFR	DP,A	RECOVER ADDRESS
	TFR	B,DP	SAVE BAD RAM MAP
*
RAM16	LDB	#$38	RESET WATCHDOG
	STB	$C3FC
	CLRB
RAM17	EXG	X,D
	CMPX	#$C000	CHECK FOR END OF MEMORY
	LBNE	RAM7	NO?, LOOP
	LEAY	-1,Y
	LBNE	RAM2	REPEAT TEST
	TFR	CC,B
	TSTB		CHECK AUTO CYCLE NOT FLAG  <================TEMPORARY
	BMI	RAM17B	CLEAR, CONTINUE RAM TEST
	LDB	#DIABLK	SELECT DIAGNOSTIC BLOCK
	STB	MAPCR	IN FLAG
	STB	MAPC
	JSR	INIT	INITIALIZE DIRECT PAGE VARIABLES
	JMP	VOUND0	NEXT TEST IN AUTO CYCLE
RAM17B	BITB	#$10	CHECK COMPREHENSIVE/INITIAL FLAG-SAVE RANDOM NUMBER
	LBNE	RAM2	COMPREHENSIVE, CONTINUE
* FIND GOOD RAM
	LDA	#$9E
	TFR	DP,B	GET BAD RAM MAP
	TSTB
	BEQ	RAM19	DP <= $9E, IF ALL RAM OK
RAM18	INCA		DP <= $9F, IF (BLOCK 2 OR 3 BAD) AND 1 OK
	LSRB		DP <= $A0, IF BLOCK 1 BAD AND 2 OK
	BCS	RAM18	DP <= $A1, IF ONLY BLOCK 3 OK
RAM19	TFR	A,DP	DP <= $A2, IF ALL BLOCKS BAD, GOOD LUCK!
	ADDA	#$1C	SET HARDWARE STACK AT TOP OF GOOD RAM BLOCK
	CLRB
	TFR	D,S
	JSR	INIT	SET UP FOR TEXT ROUTINES
* 
* POWER UP ROM TEST
*
ROM0	LDU	#ROMMAP	GET ROM MAP ADDRESS
ROM1	LDA	,U	GET ROM DESCRIPTOR BYTE
	BEQ	ROM9	NO ROM AT POSITION
	ANDA	#$70	EXTRACT ADDRESS
	LSRA
	ADDA	#$C0
	CLRB
	TFR	D,X	INTO X REGESTER
	LDD	#0	ZERO CHECKSUM COUNTER
ROM2	ADDD	,X	FAST CHECKSUM ADDER
	BCC	ROM3
	ADDD	#1
ROM3	ADDD	2,X
	BCC	ROM4
	ADDD	#1
ROM4	ADDD	4,X
	BCC	ROM5
	ADDD	#1
ROM5	ADDD	6,X
	BCC	ROM6
	ADDD	#1
ROM6	LEAX	8,X	ADVANCE POINTER
	EXG	D,X	CHECK IF DONE
	TSTB
	BNE	ROM7
	LDB	#$38	RESET WATCHDOG
	STB	$C3FC
	CLRB
	BITA	#7
	BEQ	ROM8
ROM7	EXG	D,X
	BRA	ROM2	CONTINUE TESTING
ROM8	CMPX	#0	CHECK CHECKSUM
	BEQ	ROM9
	TFR	CC,A	GET COMPREHENSIVE/INITIAL FLAG
	BITA	#$10	TEST IT
	BEQ	IDIS20	DISPLAY INITIAL ERROR
	LDA	#DIABLK	SELECT DIAGNOSTIC BLOCK
	STA	MAPCR	IN FLAG
	STA	MAPC
	RTS		RETURN TO COMPREHENSIVE DIAGNOSTICS
ROM9	LEAU	1,U
	CMPU	#ROMMAP+24
	BNE	ROM1
	TFR	CC,A
	BITA	#$10	TEST COMPREHENSIVE/INITIAL FLAG
	BEQ	IDIS1	DISPLAY INITIAL ROM OK
	LDA	#DIABLK	SELECT DIAGNOSTIC BLOCK
	STA	MAPC
	RTS		RETURN TO COMPREHENSIVE DIAGNOSTICS
*
* INITIAL TEST RESULTS DISPLAY
*
IDIS1	TFR	DP,A	CHECK IF RAM OK <== ROM OK STARTING POINT
	CMPA	#$9E
	BNE	IDIS10	BRANCH IF RAM BAD
* ROM OK, RAM OK
	LDA	#DIABLK
	STA	MAPCR	SAVE STATUS
	STA	MAPC	SELECT DIAGNOSTIC BLOCK
	JSR	VORAOK
	JMP	GAMEOV	NOW GO TO GAME OVER
* ROM OK, RAM BAD
IDIS10	LDB	#$40	BAD RAM INDICATION LEDS
	STB	$CC00
	STB	$CC02
	LDA	#DIABLK	SELECT DIAGNOSTIC BLOCK
	STA	MAPCR	IN FLAG
	STA	MAPC
	JSR	VOOKRB
	JMP	GAMEOV	NOW GO TO GAME OVER
* ROM BAD
IDIS20	LDB	#$80	BAD ROM INDICATION LEDS
	STB	$CC00
	STB	$CC02
	LDA	#DIABLK	SELECT DIAGNOSTIC BLOCK
	STA	MAPCR	IN FLAG
	STA	MAPC
	JSR	VOMBAD
	JMP	GAMEOV	NOW TO GAME OVER
*
* STORE B,X BLOCK 0
*
STBXB0	PSHS	A,CC
	LDA	MAPCR
	PSHS	A
	CLR	MAPCR
	CLR	MAPC
	STB	,X
STBXB	PULS	A
	STA	MAPCR
	STA	MAPC
	PULS	CC,A,PC
*
* LOAD B ,X - BLOCK 0
*
LDBXB0	PSHS	A,CC	SAVE STATE
	LDA	MAPCR	GET CURRENT ACTIVE BLOCK
	PSHS	A	SAVE IT
	CLR	MAPCR	MAKE IT 0
	CLR	MAPC	AND IN HARDWARE
	LDB	,X	GET THE DATA
	BRA	STBXB	FINISH ABOVE
*
* GAME OVER- ASSUMES BLOCK 3 REMAINS SELECTED!!!!
*
GAMEOV	ORCC	#$90	SET TO COMPR/NOT AUTO CYCLE
	LDB	#$38	GET DOGGY
	LDX	#$C3FC
	BSR	STBXB0	DO IT
	CLR	CREDIT	REMOVE ANY LEFTOVERS
	CLR	BUNITS
	CLR	CUNITS
	JSR	SCRCLR	CLEAR UP
	JSR	VPWRUP
	LDB	#$A5	COLOR LETTERS WHITE
	LDX	#LETCOL	POINT TO IT
	BSR	STBXB0	SET COLOR UP
	LDU	#VGAMOV	"GAME OVER"
	LDX	#$3880	SCREEN ADDRESS
	JSR	LJSR	DO IT
	FDB	TV1
	FCB	2	IN BLOCK 2 WRITE TEXT
	LDB	#$38	GET DOGGY
	LDX	#$C3FC
	BSR	STBXB0	DO IT
	LDY	#IGAMEO	GIVE INSTRUCTIONS
	JSR	LJSR	DO IT
	FDB	TV12
	FCB	2
GAMOV1	LDX	#$CC01	READ FOR SLAM TILT
	JSR	LDBXB0	AND SEE WHAT'S HAPPENING
	BITB	#$40	SLAM?
	BEQ	GAMOV2	NO
	JMP	RESET	YES, GO BACK
GAMOV2	LDX	#$CC00	NOW READ SWS
	JSR	LDBXB0	AND SEE IF ANY?
	BITB	#$2	ADV?
	BEQ	GAMOV3	NO, SEE IF ANY OTHERS
	BITB	#1	AUTO/MANUAL
	BNE	GAMOV4	AUTO-GO TO AUDIT
	JMP	VCROM0	MANUAL GO TO SELF TEST
GAMOV4	JMP	VUDITG
GAMOV3	BITB	#$04	RIGHT COIN?
	BEQ	GAMOV5	NO
	JSR	RCOINV
GOVERX	LDY	#100	DELAY
GOVER1	LDA	#$B2
GOVER2	DECA
	BNE	GOVER2
	LDB	#$38	RESET WATCHDOG
	LDX	#$C3FC
	JSR	STBXB0	DO IT
	LEAY	-1,Y
	BNE	GOVER1	LOOP AROUND
	BRA	GAMOV1	MONITOR SWITCHES ONLY
GAMOV5	BITB	#$20	CENTER COIN?
	BEQ	GAMOV6	NO
	JSR	CCOINV
	BRA	GOVERX	DELAY THEN BACK
GAMOV6	BITB	#$10	LEFT COIN?
	BEQ	GOVERX	NO, DELAY
	JSR	LCOINV
	BRA	GOVERX	EXIT AFTER 1/2 SEC
*
* SYSTEM FIRMWARE
*
*WRITE AN OBJECT TO SCREEN
*Y=OBJECT DESCRIPTOR ADDR
*D=SCREEN ADDR
*ALL SAVED
*REENTRANT
*
*
CWRIT	PSHS	A,B,X,Y,U
	TFR	D,X
	LDD	,Y	GET WIDTH,LENGTH
	LDY	2,Y	GET DATA
	PSHS	D	SAVE WIDTH,HEIGHT
	BITB	#1	ODD LENGTH?
	BNE	CWRT1
*EVEN BYTE COUNT
CWRT00	SUBB	#2
CWRT0	LDU	B,Y
	STU	B,X
	SUBB	#2
	BPL	CWRT0
	LDB	1,S
	LEAX	$100,X
	LEAY	B,Y
	DECA
	BNE	CWRT00
	BRA	CWRTX
*ODD BYTE COUNT
CWRT1	DECB
	LDA	B,Y
	STA	B,X
	SUBB	#2
	BMI	CWRT3
CWRT2	LDU	B,Y
	STU	B,X
	SUBB	#2
	BPL	CWRT2
CWRT3	LDB	1,S	GET HEIGHT
	LEAX	$100,X
	LEAY	B,Y
	DEC	,S	DEC WIDTH
	BNE	CWRT1
CWRTX	LEAS	2,S	PULL TWO
	PULS	A,B,X,Y,U,PC
*
*COFF
*Y=OBJECT DESCRIPTOR ADDR
*D=SCREEN ADDR
*
COFF	PSHS	A,B,X,U
	TFR	D,X
	LDD	,Y	GET WIDTH ,HEIGHT
COFFA	LDU	#0
	PSHS	B	SAVE HT
	BITB	#1	ODD LENGTH?
	BNE	COFF1	YES
*EVEN BYTE COUNT
COFF00	SUBB	#2
COFF0	STU	B,X
	SUBB	#2
	BPL	COFF0
	LDB	,S	GET HT
	LEAX	$100,X
	DECA
	BNE	COFF00
	BRA	COFFX
*ODD BYTE COUNT
COFF1	DECB
	CLR	B,X
	SUBB	#2
	BMI	COFF3
COFF2	STU	B,X
	SUBB	#2
	BPL	COFF2
COFF3	LDB	,S	GET HT
	LEAX	$100,X
	DECA
	BNE	COFF1
COFFX	LEAS	1,S	PULL HEIGHT
	PULS	A,B,X,U,PC
*
*BLOCK CLEAR
*X=ADDR, D=W,H
*
BLKCLR	PSHS	A,B,X,U
	LDA	MAPCR	SAVE MAP
	PSHS	A
	LDA	1,S
	BRA	COFFA
*
*SCREEN CLEAR
*
SCRCLR	PSHS	D,X,Y,U
	LDU	#$9C00
	LDX	#0
	TFR	X,Y
	TFR	X,D
SCLRLP	PSHU	X,Y,D
	PSHU	X,Y,D
	PSHU	X,Y,D
	PSHU	X,Y,D
	PSHU	X,Y,D
	PSHU	X	32 AT A CRACK
	CMPU	#0
	BNE	SCLRLP
	PULS	D,X,Y,U,PC
*
* INITIALIZE DP VARIABLES FOR TEXT/DIAG USE
*
INIT	PSHS	D	SAVE STATE
	CLR	MESPT
	CLR	ASCNTR
	LDA	#DIABLK	SELECT DIAG BLOCK
	STA	MAPCR	INTO CURRENT
	STA	ASLAST
	LDD	#$FFFF	INIT NUMBER
	STD	NUMBER
	PULS	D,PC	GO BACK
*
* CMOS PRIMITIVE FOR READING
*
RCMOS	LDA	1,X	GET LSB
	ANDA	#$0F	LEAVE ONLY LS
	PSHS	A	SAVE IT
	LDA	,X++	GET MSB + AUTO INC
	ASLA
	ASLA
	ASLA
	ASLA		SHIFT LS TO MSB
	ADDA	,S+	GET LSB + FIX STACK
	RTS		BYE
*
* READ CMOS INTO A
*
RCMOSA	PSHS	B	SAVE A WHILE
	LDB	MAPCR	GET CURRENT
	PSHS	B	SAVE IT
	CLR	MAPCR	NOW SET TO BLOCK 0
	CLR	MAPC	AND HARDWARE
	BSR	RCMOS	GO READ IT IN A
RCMOSX	PULS	B	GET OLD BLOCK #
	STB	MAPCR	SAVE IT AGAIN
	STB	MAPC	AND IN HARDWARE
	PULS	B,PC	CLEAN + GO
*
* READ CMOS INTO D POINTED TO BY X: A=X,X+1; B=X+2,X+3
*
RCMOSD	BSR	RCMOSA	GET THE FIRST BYTE+FALL THRU FOR 2ND
*
* READ CMOS INTO B POINTED TO BY X
*
RCMOSB	PSHS	A	SAVE A
	BSR	RCMOSA	GET IN A
	TFR	A,B	PUT IT IN B
	PULS	A,PC	DONE
*
* WRITE TO CMOS PRIMITIVE
*
WCMOS	PSHS	A	SAVE WHATS TO BE WRITTEN
	STA	1,X	SAVE LSB
	LSRA		SHIFT MS TO LS
	LSRA
	LSRA
	LSRA
	STA	,X++	SAVE MSB AND AUTO INC
	PULS	A,PC	DONE
*
* WRITE TO CMOS FROM A AT X
*
WCMOSA	PSHS	B	SAVE STATE
	LDB	MAPCR	GET CURRENT MAP
	PSHS	B	SAVE ON STACK
	CLR	MAPCR	POINT TO BLOCK 0
	CLR	MAPC	AND IN HARDWARE
	BSR	WCMOS	WRITE A TO CMOS
	PULS	B	GET BLOCK SAVED
	STB	MAPCR	SAVE IT
	STB	MAPC	AND IN HARDWARE
	PULS	B,PC	CLEAN UP + GO
*
* WRITE CMOS FROM D TO X: A=X,X+1; B=X+2,X+3
*
WCMOSD	BSR	WCMOSA	DO IT AND FALL THRU FOR 2ND
*
* WRITE CMOS FROM B TO X
*
WCMOSB	PSHS	A	SAVE A
	TFR	B,A	MOVE B TO A
	BSR	WCMOSA	FAKE IT
	PULS	A,PC	DONE
*
* LJSR HERE
*
LJSR	LEAS	-3,S	MAKE ROOM
	PSHS	A,U	SAVE TEMPS
	LDA	MAPCR	GET BLOCK
	STA	5,S	PUT WITH RETURN ADDR
	LDU	6,S	GET "RETURN ADDR"
	LDA	2,U	GET NEW BLOCK
	LDU	,U
	STU	3,S
	STA	MAPCR	MAKE NEW BLOCK
	STA	MAPC	AND IN HARDWARE
	PULS	A,U	RESTORE
	JSR	[0,S]	DO IT INDIRECT
	PSHS	A,U	SAVE AGAIN
	LDA	5,S	GET OLD BLOCK BACK
	STA	MAPCR	HOW BORING
	STA	MAPC
	LDU	6,S	GET   "RETURN ADDR"
	LEAU	3,U	MAKE REAL
	STU	6,S	PUT BACK ON STACK
	PULS	A,U	RESTORE
	LEAS	3,S	TAKE AWAY BYTEE
	RTS		AND GET THE PHUCK OUT OF HERE.
*
* ROM ADDRESS MAP - ONE BYTE EVERY 2K 
*                   FIRST 2 BYTES FOR ROM1,
*                    NEXT 2 BYTES FOR ROM2, ETC.
*
*       BITS 0-3 BLOCK NUMBER (USE $F FOR MAIN MEMORY)
*       BITS 6-4 ADDRESS 0 FOR $C000
*                        1 FOR $C800
*                        2 FOR $D000 
*                        3 FOR $D800
*                        4 FOR $E000 
*                        5 FOR $E800 
*                        6 FOR $F000 
*                        7 FOR $F800     
*       00 FOR NO ROM
*
ROMMAP	FCB	$00,$00	ROM 1
	FCB	$00,$00	ROM 2
	FCB	$00,$00	ROM 3
	FCB	$00,$00	ROM 4
	FCB	$00,$00	ROM 5
	FCB	$00,$00	ROM 6
	FCB	$00,$00	ROM 7
	FCB	$00,$00	ROM 8
	FCB	$00,$00	ROM 9
	FCB	$00,$00	ROM 10
	FCB	$00,$00	ROM 11
	FCB	$00,$00	ROM 12
*
* I/O EQUATES HERE
*
VORAOK	EQU	DIAORG	RORAOK
VOOKRB	EQU	DIAORG+3 ROOKRB
VOMBAD	EQU	DIAORG+6 ROMBAD
VPWRUP	EQU	DIAORG+9 PWRUP
VAUD	EQU	DIAORG+12 AUD
VAUD1	EQU	DIAORG+15 AUD1
LCOINV	EQU	DIAORG+18 COINL
RCOINV	EQU	DIAORG+21 COINR
CCOINV	EQU	DIAORG+24 COINC
RHSTDV	EQU	DIAORG+27 RHSTD
VCMOSM	EQU	DIAORG+30 CMOSMV
VUDITG	EQU	DIAORG+33 AUDITG
VUTOCY	EQU	DIAORG+36 AUTOCY
VCROM0	EQU	DIAORG+39 CROM0
VRAM10	EQU	DIAORG+42 CRAM10
VRAM20	EQU	DIAORG+45 CRAM20
VOUND0	EQU	DIAORG+48 SOUND0
*
* VECTORS TO ROUTINES HERE
*
	ORG	$FF9D	FOR NOW
	RMB	2	NULOBV
RMAPV	FDB	ROMMAP
RCAV	JMP	RCMOSA
RCBV	JMP	RCMOSB
RCDV	JMP	RCMOSD
WCAV	JMP	WCMOSA
WCBV	JMP	WCMOSB
WCDV	JMP	WCMOSD
CWRITV	JMP	CWRIT
COFFV	JMP	COFF
BLKCLV	JMP	BLKCLR
SCRCLV	JMP	SCRCLR
ROM0V	JMP	ROM0
ROM9V	JMP	ROM9
RAM2V	JMP	RAM2
VAMEOV	JMP	GAMEOV
	RMB	3	"BGIV"
LJSRV	JMP	LJSR
	RMB	3	"SLEPPV"
STBXBV	JMP	STBXB0
LDBXBV	JMP	LDBXB0
*
* RESET VECTOR
*
	ORG	$FFFC
	FDB	RESET	NMI TOO
	FDB	RESET
	PAGE
